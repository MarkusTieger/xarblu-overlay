diff --git a/Cargo.lock b/Cargo.lock
index 4ee3173..c1968bd 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -151,7 +151,7 @@ dependencies = [
 
 [[package]]
 name = "e621_downloader"
-version = "1.7.0"
+version = "1.7.0-hotfix.1"
 dependencies = [
  "base64-url",
  "console",
diff --git a/Cargo.toml b/Cargo.toml
index c51f6a6..2cd711c 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "e621_downloader"
-version = "1.7.0"
+version = "1.7.0-hotfix.1"
 authors = ["McSib <mcsibsart@gmail.com>"]
 edition = "2018"
 
diff --git a/src/e621/blacklist.rs b/src/e621/blacklist.rs
index acfc71a..8afcab0 100644
--- a/src/e621/blacklist.rs
+++ b/src/e621/blacklist.rs
@@ -1,7 +1,8 @@
+use failure::ResultExt;
+
 use crate::e621::io::parser::BaseParser;
 use crate::e621::sender::entries::{PostEntry, UserEntry};
 use crate::e621::sender::RequestSender;
-use failure::ResultExt;
 
 /// Root token which contains all the tokens of the blacklist.
 #[derive(Default, Debug)]
diff --git a/src/e621/grabber.rs b/src/e621/grabber.rs
index 1ca9cf7..370f505 100644
--- a/src/e621/grabber.rs
+++ b/src/e621/grabber.rs
@@ -3,8 +3,8 @@ use std::cmp::Ordering;
 use std::rc::Rc;
 
 use crate::e621::blacklist::Blacklist;
-use crate::e621::io::tag::{Group, Tag, TagCategory, TagType};
 use crate::e621::io::Login;
+use crate::e621::io::tag::{Group, Tag, TagCategory, TagType};
 use crate::e621::sender::entries::{PoolEntry, PostEntry, SetEntry};
 use crate::e621::sender::RequestSender;
 
diff --git a/src/e621/io/mod.rs b/src/e621/io/mod.rs
index f95d473..1b033f4 100644
--- a/src/e621/io/mod.rs
+++ b/src/e621/io/mod.rs
@@ -24,7 +24,7 @@ pub struct Config {
 
 impl Config {
     /// Checks config and ensure it isn't missing.
-    fn config_exists() -> bool {
+    pub fn config_exists() -> bool {
         if !Path::new(CONFIG_NAME).exists() {
             trace!("config.json: does not exist!");
             return false;
@@ -34,24 +34,13 @@ impl Config {
     }
 
     /// Creates config file.
-    fn create_config() -> Result<(), Error> {
+    pub fn create_config() -> Result<(), Error> {
         let json = to_string_pretty(&Config::default())?;
         write(Path::new(CONFIG_NAME), json)?;
 
         Ok(())
     }
 
-    /// Checks if config exist and, if not, creates config template.
-    pub fn check_config() -> Result<(), Error> {
-        if !Config::config_exists() {
-            info!("Creating config file...");
-            Config::create_config()?;
-            trace!("Config file created!")
-        }
-
-        Ok(())
-    }
-
     /// Loads and returns `config` for quick management and settings.
     pub fn get_config() -> Result<Config, Error> {
         let config: Config = from_str(&read_to_string(CONFIG_NAME).unwrap())?;
diff --git a/src/e621/io/tag.rs b/src/e621/io/tag.rs
index 8a5725d..a6162e2 100644
--- a/src/e621/io/tag.rs
+++ b/src/e621/io/tag.rs
@@ -1,5 +1,4 @@
-use std::fs::{read_to_string, write};
-use std::path::Path;
+use std::fs::read_to_string;
 
 use failure::{Error, ResultExt};
 
@@ -10,7 +9,7 @@ use crate::e621::sender::RequestSender;
 
 /// Constant of the tag file's name.
 pub const TAG_NAME: &str = "tags.txt";
-const TAG_FILE_EXAMPLE: &str = include_str!("tags.txt");
+pub const TAG_FILE_EXAMPLE: &str = include_str!("tags.txt");
 
 /// Returns `T` if it isn't an error. If it is, it will run a closure that is expected to panic.
 trait UnwrapOrFail<T> {
@@ -109,22 +108,6 @@ impl Group {
     }
 }
 
-/// Creates tag file if it doesn't exist.
-pub fn create_tag_file() -> Result<(), Error> {
-    if !Path::new(TAG_NAME).exists() {
-        info!("Tag file does not exist, crating tag file...");
-        write(TAG_NAME, TAG_FILE_EXAMPLE)?;
-        trace!("Tag file created...");
-
-        emergency_exit(
-            "The tag file is created, the application will close so you can include \
-             the artists, sets, pools, and individual posts you wish to download.",
-        );
-    }
-
-    Ok(())
-}
-
 /// Creates instance of the parser and parses groups and tags.
 pub fn parse_tag_file(request_sender: &RequestSender) -> Result<Vec<Group>, Error> {
     TagParser {
diff --git a/src/e621/mod.rs b/src/e621/mod.rs
index c6ac660..5087afa 100644
--- a/src/e621/mod.rs
+++ b/src/e621/mod.rs
@@ -3,18 +3,19 @@ use std::fs::{create_dir_all, write};
 use std::path::PathBuf;
 use std::rc::Rc;
 
-use indicatif::ProgressBar;
+use dialoguer::Confirm;
+use failure::ResultExt;
 use indicatif::{ProgressDrawTarget, ProgressStyle};
+use indicatif::ProgressBar;
 
-use crate::e621::sender::entries::UserEntry;
 use blacklist::Blacklist;
-use dialoguer::Confirm;
-use failure::ResultExt;
 use grabber::Grabber;
-use io::tag::Group;
 use io::Config;
+use io::tag::Group;
 use sender::RequestSender;
 
+use crate::e621::sender::entries::UserEntry;
+
 pub mod blacklist;
 pub mod grabber;
 pub mod io;
@@ -55,6 +56,7 @@ impl WebConnector {
     /// Gets input and checks if the user wants to enter safe mode.
     /// If they do, the `RequestSender` will update the request urls for future sent requests.
     pub fn should_enter_safe_mode(&mut self) {
+        trace!("Prompt for safe mode...");
         let confirm_prompt = Confirm::new()
             .with_prompt("Should enter safe mode?")
             .show_default(true)
@@ -66,6 +68,8 @@ impl WebConnector {
                 format!("{}", e)
             })
             .unwrap();
+
+        trace!("Safe mode decision: {}", confirm_prompt);
         if confirm_prompt {
             self.request_sender.update_to_safe();
         }
@@ -104,6 +108,7 @@ impl WebConnector {
                 format!("{}", e)
             })
             .unwrap();
+        trace!("Saved {}...", file_path);
     }
 
     /// Removes invalid characters from directory name.
@@ -120,13 +125,27 @@ impl WebConnector {
     /// Processes `PostSet` and downloads all posts from it.
     fn download_collection(&mut self) {
         for collection in &self.grabber.posts {
+            let static_path: PathBuf = [
+                &self.download_directory,
+                &collection.category,
+                &self.remove_invalid_chars(&collection.name),
+            ]
+            .iter()
+            .collect();
+            trace!("Printing Collection Info:");
+            trace!("Collection Name:            \"{}\"", collection.name);
+            trace!("Collection Category:        \"{}\"", collection.category);
+            trace!("Collection Post Length:     \"{}\"", collection.posts.len());
+            trace!(
+                "Static file path for this collection: \"{}\"",
+                static_path.to_str().unwrap()
+            );
+
             for post in &collection.posts {
                 self.progress_bar
                     .set_message(&format!("Downloading: {} ", collection.name));
                 let file_path: PathBuf = [
-                    &self.download_directory,
-                    &collection.category,
-                    &self.remove_invalid_chars(&collection.name),
+                    &static_path.to_str().unwrap().to_string(),
                     &self.remove_invalid_chars(&post.name),
                 ]
                 .iter()
@@ -155,6 +174,8 @@ impl WebConnector {
                 self.save_image(file_path.to_str().unwrap(), &bytes);
                 self.progress_bar.inc(post.file_size as u64);
             }
+
+            trace!("Collection {} is finished downloading...", collection.name);
         }
     }
 
@@ -178,6 +199,7 @@ impl WebConnector {
     pub fn download_posts(&mut self) {
         // Initializes the progress bar for downloading.
         let length = self.get_total_file_size();
+        trace!("Total file size for all images grabbed is {}KB", length);
         self.initialize_progress_bar(length);
         self.download_collection();
         self.progress_bar.finish_and_clear();
diff --git a/src/e621/sender/entries.rs b/src/e621/sender/entries.rs
index 45ba6c4..1b2209b 100644
--- a/src/e621/sender/entries.rs
+++ b/src/e621/sender/entries.rs
@@ -1,6 +1,7 @@
-use crate::e621::io::tag::TagType;
 use serde::{Deserialize, Serialize};
 
+use crate::e621::io::tag::TagType;
+
 /// GET return of alias entry for e621/e926.
 #[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
 pub struct AliasEntry {
diff --git a/src/e621/sender/mod.rs b/src/e621/sender/mod.rs
index 34e05b0..568f3e0 100644
--- a/src/e621/sender/mod.rs
+++ b/src/e621/sender/mod.rs
@@ -32,7 +32,14 @@ macro_rules! hashmap {
 }
 
 /// Default user agent value.
-const USER_AGENT_VALUE: &str = "e621_downloader/1.7.0 (by McSib on e621)";
+const USER_AGENT_VALUE: &str = concat!(
+    env!("CARGO_PKG_NAME"),
+    "/",
+    env!("CARGO_PKG_VERSION"),
+    " (by ",
+    env!("CARGO_PKG_AUTHORS"),
+    " on e621)"
+);
 
 /// Sender client is a modified form of the generic client, wrapping the client in a `Rc` so the sender client can be cloned without creating another instance of the root client.
 struct SenderClient {
@@ -44,6 +51,11 @@ struct SenderClient {
 impl SenderClient {
     /// Creates root client for the `SenderClient`.
     fn new(auth: String) -> Self {
+        trace!(
+            "SenderClient initializing with USER_AGENT_VALUE \"{}\"",
+            USER_AGENT_VALUE
+        );
+
         SenderClient {
             client: Rc::new(SenderClient::build_client()),
             auth: Rc::new(auth),
diff --git a/src/main.rs b/src/main.rs
index f2aa5df..5e73c32 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -3,11 +3,14 @@ extern crate failure;
 #[macro_use]
 extern crate log;
 
+use std::env::consts::{
+    ARCH, DLL_EXTENSION, DLL_PREFIX, DLL_SUFFIX, EXE_EXTENSION, EXE_SUFFIX, FAMILY, OS,
+};
 use std::fs::File;
 
 use failure::Error;
 use simplelog::{
-    ColorChoice, CombinedLogger, Config, ConfigBuilder, LevelFilter, TermLogger, TerminalMode,
+    ColorChoice, CombinedLogger, Config, ConfigBuilder, LevelFilter, TerminalMode, TermLogger,
     WriteLogger,
 };
 
@@ -16,6 +19,18 @@ use crate::program::Program;
 mod e621;
 mod program;
 
+fn log_system_information() {
+    trace!("Printing system information out into log for debug purposes...");
+    trace!("ARCH:           \"{}\"", ARCH);
+    trace!("DLL_EXTENSION:  \"{}\"", DLL_EXTENSION);
+    trace!("DLL_PREFIX:     \"{}\"", DLL_PREFIX);
+    trace!("DLL_SUFFIX:     \"{}\"", DLL_SUFFIX);
+    trace!("EXE_EXTENSION:  \"{}\"", EXE_EXTENSION);
+    trace!("EXE_SUFFIX:     \"{}\"", EXE_SUFFIX);
+    trace!("FAMILY:         \"{}\"", FAMILY);
+    trace!("OS:             \"{}\"", OS);
+}
+
 fn main() -> Result<(), Error> {
     let mut config = ConfigBuilder::new();
     config.add_filter_allow_str("e621_downloader");
@@ -34,6 +49,8 @@ fn main() -> Result<(), Error> {
     ])
     .unwrap();
 
+    log_system_information();
+
     let program = Program::new();
     program.run()
 }
diff --git a/src/program.rs b/src/program.rs
index c5c7666..1a84cce 100644
--- a/src/program.rs
+++ b/src/program.rs
@@ -1,10 +1,18 @@
+use std::env::current_dir;
+use std::fs::write;
+use std::path::Path;
+
+use console::Term;
 use failure::Error;
 
-use crate::e621::io::tag::{create_tag_file, parse_tag_file};
-use crate::e621::io::{Config, Login};
+use crate::e621::io::{Config, emergency_exit, Login};
+use crate::e621::io::tag::{parse_tag_file, TAG_FILE_EXAMPLE, TAG_NAME};
 use crate::e621::sender::RequestSender;
 use crate::e621::WebConnector;
-use console::Term;
+
+const NAME: &str = env!("CARGO_PKG_NAME");
+const VERSION: &str = env!("CARGO_PKG_VERSION");
+const AUTHORS: &str = env!("CARGO_PKG_AUTHORS");
 
 pub struct Program {}
 
@@ -15,31 +23,60 @@ impl Program {
 
     pub fn run(&self) -> Result<(), Error> {
         Term::stdout().set_title("e621 downloader");
-        trace!("Starting downloader...");
+        trace!("Starting e621 downloader...");
+        trace!("Program Name: {}", NAME);
+        trace!("Program Version: {}", VERSION);
+        trace!("Program Authors: {}", AUTHORS);
+        trace!(
+            "Program Working Directory: {}",
+            current_dir()
+                .expect("Unable to get working directory!")
+                .to_str()
+                .unwrap()
+        );
 
         // Check the config file and ensures that it is created.
-        Config::check_config()?;
+        trace!("Checking if config file exists...");
+        if !Config::config_exists() {
+            trace!("Config file doesn't exist...");
+            info!("Creating config file...");
+            Config::create_config()?;
+        }
 
         // Create tag if it doesn't exist.
-        create_tag_file()?;
+        trace!("Checking if tag file exists...");
+        if !Path::new(TAG_NAME).exists() {
+            info!("Tag file does not exist, creating tag file...");
+            write(TAG_NAME, TAG_FILE_EXAMPLE)?;
+            trace!("Tag file \"{}\" created...", TAG_NAME);
+
+            emergency_exit(
+                "The tag file is created, the application will close so you can include \
+             the artists, sets, pools, and individual posts you wish to download.",
+            );
+        }
 
         // Creates connector and requester to prepare for downloading posts.
         let login = Login::load().unwrap();
+        trace!("Login information loaded...");
+        trace!("Login Username: {}", login.username);
+        trace!("Login API Key: {}", "*".repeat(login.api_key.len()));
+        trace!("Login Download Favorites: {}", login.download_favorites);
+
         let request_sender = RequestSender::new(&login);
         let mut connector = WebConnector::new(&request_sender);
         connector.should_enter_safe_mode();
 
         // Parses tag file.
+        trace!("Parsing tag file...");
         let groups = parse_tag_file(&request_sender)?;
-        info!("Read tag file...");
-        trace!("Parsed tag data, now attempting to obtain user blacklist...");
 
         // Collects all grabbed posts and moves it to connector to start downloading.
         if !login.is_empty() {
+            trace!("Parsing user blacklist...");
             connector.process_blacklist(&login.username);
-            trace!("Parsed and processed user blacklist...")
         } else {
-            trace!("Unable to obtain blacklist...")
+            trace!("Skipping blacklist as user is not logged in...");
         }
 
         connector.grab_all(&groups);
